<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictionary Game - Multiplayer</title>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const firebaseConfig = {
            apiKey: "AIzaSyDFlzHW747uu1p1TdqWbdFM_omkjORRht4",
            authDomain: "dictionary-5fae9.firebaseapp.com",
            databaseURL: "https://dictionary-5fae9-default-rtdb.firebaseio.com",
            projectId: "dictionary-5fae9",
            storageBucket: "dictionary-5fae9.firebasestorage.app",
            messagingSenderId: "615496664058",
            appId: "1:615496664058:web:0ea7b1bd792d230cbf1a43"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const database = firebase.database();

        // Logo Component - Open Dictionary Book
        const DictionaryLogo = ({ size = 64 }) => (
            <svg width={size} height={size} viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
                {/* Book pages */}
                <path d="M30 50 L30 150 L95 160 L95 60 Z" fill="#f0f0f0" stroke="#8b5cf6" strokeWidth="3"/>
                <path d="M170 50 L170 150 L105 160 L105 60 Z" fill="#f0f0f0" stroke="#8b5cf6" strokeWidth="3"/>

                {/* Book spine shadow */}
                <path d="M95 60 L105 60 L105 160 L95 160 Z" fill="#c4b5fd"/>

                {/* Left page text lines */}
                <line x1="40" y1="75" x2="85" y2="75" stroke="#9333ea" strokeWidth="2"/>
                <line x1="40" y1="85" x2="80" y2="85" stroke="#9333ea" strokeWidth="2"/>
                <line x1="40" y1="95" x2="85" y2="95" stroke="#9333ea" strokeWidth="2"/>
                <line x1="40" y1="105" x2="75" y2="105" stroke="#9333ea" strokeWidth="2"/>

                {/* Right page text lines */}
                <line x1="115" y1="75" x2="160" y2="75" stroke="#9333ea" strokeWidth="2"/>
                <line x1="115" y1="85" x2="155" y2="85" stroke="#9333ea" strokeWidth="2"/>
                <line x1="115" y1="95" x2="160" y2="95" stroke="#9333ea" strokeWidth="2"/>
                <line x1="115" y1="105" x2="150" y2="105" stroke="#9333ea" strokeWidth="2"/>

                {/* Decorative stars/sparkles */}
                <path d="M50 130 L52 135 L57 135 L53 138 L55 143 L50 140 L45 143 L47 138 L43 135 L48 135 Z" fill="#fbbf24"/>
                <path d="M150 130 L152 135 L157 135 L153 138 L155 143 L150 140 L145 143 L147 138 L143 135 L148 135 Z" fill="#fbbf24"/>

                {/* Book cover border */}
                <rect x="28" y="48" width="144" height="4" fill="#8b5cf6" rx="2"/>
            </svg>
        );

        // Avatar options with emojis
        const avatarOptions = [
            { id: 'cat', emoji: 'üê±', label: 'Cat' },
            { id: 'dog', emoji: 'üê∂', label: 'Dog' },
            { id: 'bird', emoji: 'üê¶', label: 'Bird' },
            { id: 'hat', emoji: 'üé©', label: 'Hat' },
            { id: 'car', emoji: 'üöó', label: 'Car' },
            { id: 'bulb', emoji: 'üí°', label: 'Light Bulb' },
            { id: 'snake', emoji: 'üêç', label: 'Snake' },
            { id: 'scholar', emoji: 'üë®‚Äçüéì', label: 'Scholar' },
            { id: 'school', emoji: 'üè´', label: 'School' }
        ];

        function MultiplayerDictionaryGame() {
            const [view, setView] = useState('home');
            const [gameCode, setGameCode] = useState('');
            const [playerName, setPlayerName] = useState('');
            const [playerId, setPlayerId] = useState(null);
            const [gameData, setGameData] = useState(null);
            const [inputGameCode, setInputGameCode] = useState('');
            const [inputPlayerName, setInputPlayerName] = useState('');
            const [difficulty, setDifficulty] = useState('adult');
            const [currentWord, setCurrentWord] = useState('');
            const [realDefinition, setRealDefinition] = useState('');
            const [myDefinition, setMyDefinition] = useState('');
            const [myVote, setMyVote] = useState(null);
            const [loadingWord, setLoadingWord] = useState(false);
            const [loadingDefinition, setLoadingDefinition] = useState(false);
            const [usedWords, setUsedWords] = useState([]);
            const [skippedWords, setSkippedWords] = useState([]);
            const [availableGames, setAvailableGames] = useState([]);
            const [gameHistory, setGameHistory] = useState([]);
            const [selectedAvatar, setSelectedAvatar] = useState('cat');

            // Try to restore session from localStorage
            useEffect(() => {
                const savedGameCode = localStorage.getItem('dictionaryGame_code');
                const savedPlayerId = localStorage.getItem('dictionaryGame_playerId');
                const savedPlayerName = localStorage.getItem('dictionaryGame_playerName');

                if (savedGameCode && savedPlayerId && savedPlayerName) {
                    // Check if the game still exists
                    database.ref(`games/${savedGameCode}`).once('value', (snapshot) => {
                        if (snapshot.exists()) {
                            const game = snapshot.val();
                            if (game.players && game.players[savedPlayerId]) {
                                // Player exists in game, reconnect
                                setGameCode(savedGameCode);
                                setPlayerId(savedPlayerId);
                                setPlayerName(savedPlayerName);
                                setView('game');
                                console.log('Reconnected to game:', savedGameCode);
                            } else {
                                // Player no longer in game, clear storage
                                localStorage.removeItem('dictionaryGame_code');
                                localStorage.removeItem('dictionaryGame_playerId');
                                localStorage.removeItem('dictionaryGame_playerName');
                            }
                        } else {
                            // Game no longer exists, clear storage
                            localStorage.removeItem('dictionaryGame_code');
                            localStorage.removeItem('dictionaryGame_playerId');
                            localStorage.removeItem('dictionaryGame_playerName');
                        }
                    });
                }
            }, []);

            const generateGameCode = () => {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            };

            const createGame = async () => {
                const code = generateGameCode();
                const newPlayerId = Date.now().toString();

                await database.ref(`games/${code}`).set({
                    host: newPlayerId,
                    hostName: playerName,
                    state: 'setup',
                    createdAt: Date.now(),
                    lastActivity: Date.now(),
                    players: {
                        [newPlayerId]: {
                            name: playerName,
                            score: 0,
                            isHost: true,
                            avatar: selectedAvatar
                        }
                    }
                });

                // Save to localStorage for reconnection
                localStorage.setItem('dictionaryGame_code', code);
                localStorage.setItem('dictionaryGame_playerId', newPlayerId);
                localStorage.setItem('dictionaryGame_playerName', playerName);

                setGameCode(code);
                setPlayerId(newPlayerId);
                setView('game');
            };

            const joinGame = async () => {
                if (!inputGameCode || !inputPlayerName) {
                    alert('Please enter both game code and your name');
                    return;
                }

                const code = inputGameCode.toUpperCase();
                const snapshot = await database.ref(`games/${code}`).once('value');

                if (!snapshot.exists()) {
                    alert('Game not found');
                    return;
                }

                const game = snapshot.val();

                // Check for duplicate names
                const existingPlayers = Object.values(game.players || {});
                const nameTaken = existingPlayers.some(player =>
                    player.name.toLowerCase() === inputPlayerName.trim().toLowerCase()
                );

                if (nameTaken) {
                    alert(`The name "${inputPlayerName}" is already taken in this game. Please choose a different name.`);
                    return;
                }

                const newPlayerId = Date.now().toString();

                await database.ref(`games/${code}/players/${newPlayerId}`).set({
                    name: inputPlayerName,
                    score: 0,
                    isHost: false,
                    avatar: selectedAvatar
                });

                await database.ref(`games/${code}/lastActivity`).set(Date.now());

                // Save to localStorage for reconnection
                localStorage.setItem('dictionaryGame_code', code);
                localStorage.setItem('dictionaryGame_playerId', newPlayerId);
                localStorage.setItem('dictionaryGame_playerName', inputPlayerName);

                setGameCode(code);
                setPlayerId(newPlayerId);
                setPlayerName(inputPlayerName);
                setView('game');
            };

            // Load available games
            useEffect(() => {
                if (view === 'join') {
                    const gamesRef = database.ref('games');

                    gamesRef.on('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            const games = Object.entries(data)
                                .filter(([code, game]) => {
                                    // Filter out old games (older than 24 hours)
                                    const age = Date.now() - (game.lastActivity || game.createdAt || 0);
                                    return age < 24 * 60 * 60 * 1000;
                                })
                                .map(([code, game]) => ({
                                    code,
                                    hostName: game.hostName,
                                    playerCount: Object.keys(game.players || {}).length,
                                    state: game.state,
                                    createdAt: game.createdAt
                                }))
                                .sort((a, b) => b.createdAt - a.createdAt);

                            setAvailableGames(games);
                        } else {
                            setAvailableGames([]);
                        }
                    });

                    return () => gamesRef.off();
                }
            }, [view]);

            // Load game history
            useEffect(() => {
                if (view === 'home' || view === 'join') {
                    const historyRef = database.ref('gameHistory');

                    historyRef.orderByChild('endedAt').limitToLast(10).on('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            const history = Object.values(data)
                                .sort((a, b) => b.endedAt - a.endedAt);
                            setGameHistory(history);
                        } else {
                            setGameHistory([]);
                        }
                    });

                    return () => historyRef.off();
                }
            }, [view]);

            useEffect(() => {
                if (gameCode && view === 'game') {
                    const gameRef = database.ref(`games/${gameCode}`);

                    gameRef.on('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            setGameData(data);
                            // Load word history
                            if (data.usedWords) {
                                setUsedWords(data.usedWords);
                            }
                            if (data.skippedWords) {
                                setSkippedWords(data.skippedWords);
                            }
                        }
                    });

                    return () => gameRef.off();
                }
            }, [gameCode, view]);

            const getRandomWord = async () => {
                setLoadingWord(true);
                try {
                    let word = null;

                    console.log('=== RANDOM WORD DEBUG ===');
                    console.log('Difficulty:', difficulty);

                    if (difficulty === 'kids') {
                        const topics = ['animals', 'nature', 'school', 'food', 'sports', 'weather'];
                        const topic = topics[Math.floor(Math.random() * topics.length)];
                        const apiUrl = `https://api.datamuse.com/words?topics=${topic}&max=200`;

                        console.log('API URL:', apiUrl);

                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        console.log('API Response length:', data?.length);

                        if (data && data.length > 0) {
                            // More flexible filtering for kids - 4-10 letters, prioritize common words
                            const filtered = data.filter(w =>
                                w.word.length >= 4 &&
                                w.word.length <= 10 &&
                                /^[a-z]+$/.test(w.word) // Only letters, no hyphens or spaces
                            );
                            console.log('Filtered words:', filtered.length);

                            if (filtered.length > 0) {
                                // Pick from first 50 results (more common words)
                                const wordIndex = Math.floor(Math.random() * Math.min(50, filtered.length));
                                word = filtered[wordIndex]?.word;
                            }
                        }

                        // Fallback to simple kid-friendly words
                        if (!word) {
                            const fallbackWords = [
                                'canopy', 'whimsy', 'gadget', 'mosaic', 'nimble', 'frolic', 'plume',
                                'burrow', 'ember', 'marvel', 'riddle', 'puzzle', 'fossil', 'crystal',
                                'habitat', 'mammal', 'reptile', 'migrate', 'gravity', 'energy'
                            ];
                            word = fallbackWords[Math.floor(Math.random() * fallbackWords.length)];
                            console.log('Using fallback kid word');
                        }
                    } else if (difficulty === 'teen') {
                        const apiUrl = 'https://api.datamuse.com/words?sp=?????????*&md=f&max=200';
                        console.log('API URL:', apiUrl);

                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        console.log('API Response length:', data?.length);

                        if (data && data.length > 0) {
                            const filtered = data.filter(w => {
                                const freq = w.tags?.[0]?.replace('f:', '') || '0';
                                return parseFloat(freq) < 20 && /^[a-z]+$/.test(w.word);
                            });
                            console.log('Filtered to less common:', filtered.length);

                            if (filtered.length > 0) {
                                word = filtered[Math.floor(Math.random() * filtered.length)]?.word;
                            }
                        }

                        // Fallback to teen-level words
                        if (!word) {
                            const fallbackWords = [
                                'ambiguous', 'benevolent', 'candor', 'diligent', 'ephemeral', 'facetious',
                                'gregarious', 'haphazard', 'impetuous', 'juxtapose', 'loquacious', 'melancholy'
                            ];
                            word = fallbackWords[Math.floor(Math.random() * fallbackWords.length)];
                            console.log('Using fallback teen word');
                        }
                    } else {
                        // For adults, use curated obscure words since APIs don't provide truly bizarre words
                        const obscureWords = [
                            'absquatulate', 'bumfuzzle', 'callipygian', 'defenestrate', 'erinaceous',
                            'floccinaucinihilipilification', 'gobemouche', 'higgler', 'impignorate',
                            'jentacular', 'kakistocracy', 'lollygag', 'malarkey', 'nudiustertian',
                            'octothorpe', 'pauciloquent', 'quomodocunquize', 'rhadamanthine',
                            'smellfungus', 'taradiddle', 'ulotrichous', 'vomitory', 'wabbit',
                            'xertz', 'yarborough', 'zenzizenzizenzic', 'borborygmus', 'collywobbles',
                            'donnybrook', 'fartlek', 'gardyloo', 'hobbledehoy', 'kerfuffle'
                        ];
                        word = obscureWords[Math.floor(Math.random() * obscureWords.length)];
                        console.log('Using curated obscure word for adults');
                    }

                    console.log('Selected word:', word);
                    console.log('======================');

                    if (word) {
                        setCurrentWord(word);
                    } else {
                        alert('Could not get a word. Please try again or enter one manually.');
                    }
                } catch (error) {
                    console.error('Error getting word:', error);
                    alert('Error fetching word. Please try again or enter one manually.');
                }
                setLoadingWord(false);
            };

            const getDefinition = async () => {
                if (!currentWord.trim()) {
                    alert('Please enter a word first');
                    return;
                }

                setLoadingDefinition(true);
                try {
                    let definition = null;

                    // Try API 1: Free Dictionary API
                    console.log('Trying Free Dictionary API...');
                    try {
                        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${currentWord.toLowerCase()}`);

                        if (response.ok) {
                            const data = await response.json();
                            if (data && data[0] && data[0].meanings && data[0].meanings[0]) {
                                definition = data[0].meanings[0].definitions[0].definition;
                                console.log('Found definition in Free Dictionary API');
                            }
                        }
                    } catch (e) {
                        console.log('Free Dictionary API failed:', e);
                    }

                    // Try API 2: Wiktionary via MediaWiki API
                    if (!definition) {
                        console.log('Trying Wiktionary API...');
                        try {
                            const response = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${encodeURIComponent(currentWord.toLowerCase())}`);

                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.en && data.en[0] && data.en[0].definitions && data.en[0].definitions[0]) {
                                    definition = data.en[0].definitions[0].definition;
                                    // Clean up Wiktionary HTML/wiki markup
                                    definition = definition.replace(/<[^>]*>/g, '').replace(/\[\[([^\]]+)\]\]/g, '$1');
                                    console.log('Found definition in Wiktionary');
                                }
                            }
                        } catch (e) {
                            console.log('Wiktionary API failed:', e);
                        }
                    }

                    // Try API 3: Dictionary API (dictionaryapi.com)
                    if (!definition) {
                        console.log('Trying DictionaryAPI.com...');
                        try {
                            const response = await fetch(`https://www.dictionaryapi.com/api/v3/references/collegiate/json/${currentWord.toLowerCase()}?key=your-key-here`);
                            // Note: This requires an API key, but we'll try anyway in case it works
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data[0] && data[0].shortdef && data[0].shortdef[0]) {
                                    definition = data[0].shortdef[0];
                                    console.log('Found definition in DictionaryAPI.com');
                                }
                            }
                        } catch (e) {
                            console.log('DictionaryAPI.com failed:', e);
                        }
                    }

                    if (definition) {
                        setRealDefinition(definition.charAt(0).toUpperCase() + definition.slice(1));
                    } else {
                        alert('Could not find definition for "' + currentWord + '" in any dictionary. Please enter the definition manually or search online (try Merriam-Webster.com or Dictionary.com).');
                    }
                } catch (error) {
                    console.error('Definition fetch error:', error);
                    alert('Error fetching definition. Please enter the definition manually or search online.');
                }
                setLoadingDefinition(false);
            };

            const startRound = async () => {
                if (!currentWord || !realDefinition) {
                    alert('Please enter word and definition');
                    return;
                }

                // Check if word was already used
                const wordLower = currentWord.toLowerCase().trim();
                if (usedWords.includes(wordLower)) {
                    if (!confirm(`"${currentWord}" has been used before. Use it anyway?`)) {
                        return;
                    }
                } else {
                    // Add to used words
                    const updatedUsedWords = [...usedWords, wordLower];
                    await database.ref(`games/${gameCode}/usedWords`).set(updatedUsedWords);
                }

                await database.ref(`games/${gameCode}`).update({
                    state: 'collecting',
                    currentWord: currentWord,
                    realDefinition: realDefinition,
                    difficulty: difficulty,
                    definitions: {},
                    votes: {}
                });
            };

            const skipWord = async () => {
                if (!currentWord.trim()) {
                    alert('Please enter a word first');
                    return;
                }

                const wordLower = currentWord.toLowerCase().trim();
                const updatedSkippedWords = [...skippedWords, wordLower];
                await database.ref(`games/${gameCode}/skippedWords`).set(updatedSkippedWords);

                setCurrentWord('');
                setRealDefinition('');
                alert(`"${currentWord}" has been marked as skipped`);
            };

            const clearWordHistory = async () => {
                if (confirm('Clear all word history (used and skipped)? This cannot be undone.')) {
                    await database.ref(`games/${gameCode}`).update({
                        usedWords: [],
                        skippedWords: []
                    });
                    setUsedWords([]);
                    setSkippedWords([]);
                    alert('Word history cleared!');
                }
            };

            const endGame = async () => {
                if (!confirm('End this game and save to history? This will close the game for all players.')) {
                    return;
                }

                const players = gameData.players || {};
                const sortedPlayers = Object.entries(players)
                    .map(([id, player]) => ({ name: player.name, score: player.score }))
                    .sort((a, b) => b.score - a.score);

                // Save to history
                const historyId = `${gameCode}_${Date.now()}`;
                await database.ref(`gameHistory/${historyId}`).set({
                    gameCode,
                    players: sortedPlayers,
                    winner: sortedPlayers[0],
                    endedAt: Date.now(),
                    hostName: gameData.hostName,
                    roundsPlayed: gameData.roundsPlayed || 0
                });

                // Delete active game
                await database.ref(`games/${gameCode}`).remove();

                // Clear localStorage
                localStorage.removeItem('dictionaryGame_code');
                localStorage.removeItem('dictionaryGame_playerId');
                localStorage.removeItem('dictionaryGame_playerName');

                alert('Game ended and saved to history!');
                setView('home');
            };

            const quickJoinGame = (code) => {
                setInputGameCode(code);
            };

            const submitDefinition = async () => {
                if (!myDefinition.trim()) {
                    alert('Please enter a definition');
                    return;
                }

                await database.ref(`games/${gameCode}/definitions/${playerId}`).set({
                    text: myDefinition.trim()
                });

                setMyDefinition('');
            };

            const startVoting = async () => {
                await database.ref(`games/${gameCode}`).update({
                    state: 'voting'
                });
            };

            const castVote = async (defId) => {
                await database.ref(`games/${gameCode}/votes/${playerId}`).set(defId);
                setMyVote(defId);
            };

            const showResults = async () => {
                const votes = gameData.votes || {};
                const definitions = gameData.definitions || {};
                const players = gameData.players || {};

                const voteCounts = {};
                Object.values(votes).forEach(defId => {
                    voteCounts[defId] = (voteCounts[defId] || 0) + 1;
                });

                const updates = {};

                Object.keys(definitions).forEach(defPlayerId => {
                    if (voteCounts[defPlayerId]) {
                        const currentScore = players[defPlayerId]?.score || 0;
                        updates[`players/${defPlayerId}/score`] = currentScore + voteCounts[defPlayerId];
                    }
                });

                if (voteCounts['real']) {
                    const hostId = gameData.host;
                    const currentScore = players[hostId]?.score || 0;
                    updates[`players/${hostId}/score`] = currentScore + voteCounts['real'];
                }

                updates.state = 'results';
                updates.voteCounts = voteCounts;

                await database.ref(`games/${gameCode}`).update(updates);
            };

            const newRound = async () => {
                await database.ref(`games/${gameCode}`).update({
                    state: 'setup',
                    currentWord: null,
                    realDefinition: null,
                    definitions: null,
                    votes: null,
                    voteCounts: null,
                    roundsPlayed: (gameData.roundsPlayed || 0) + 1,
                    lastActivity: Date.now()
                });
                setCurrentWord('');
                setRealDefinition('');
                setMyDefinition('');
                setMyVote(null);
            };

            const restartRound = async () => {
                if (confirm('Restart this round? All definitions and votes will be lost.')) {
                    await database.ref(`games/${gameCode}`).update({
                        state: 'setup',
                        currentWord: null,
                        realDefinition: null,
                        definitions: null,
                        votes: null,
                        voteCounts: null
                    });
                    setCurrentWord('');
                    setRealDefinition('');
                    setMyDefinition('');
                    setMyVote(null);
                }
            };

            const changeDictionaryHolder = async (newHolderId) => {
                await database.ref(`games/${gameCode}`).update({
                    dictionaryHolder: newHolderId,
                    dictionaryHolderName: players[newHolderId]?.name
                });
            };

            const copyGameCode = () => {
                navigator.clipboard.writeText(gameCode);
                alert('Game code copied!');
            };

            const leaveGame = async () => {
                if (!confirm('Are you sure you want to leave this game? This cannot be undone.')) {
                    return;
                }

                const players = gameData.players || {};
                const isHost = gameData.host === playerId;
                const playerCount = Object.keys(players).length;

                // Remove the player from the game
                await database.ref(`games/${gameCode}/players/${playerId}`).remove();
                await database.ref(`games/${gameCode}/lastActivity`).set(Date.now());

                // If the leaving player was the host, transfer host to another player or end game
                if (isHost && playerCount > 1) {
                    const remainingPlayers = Object.entries(players).filter(([id]) => id !== playerId);
                    if (remainingPlayers.length > 0) {
                        const [newHostId, newHostPlayer] = remainingPlayers[0];
                        await database.ref(`games/${gameCode}`).update({
                            host: newHostId,
                            hostName: newHostPlayer.name,
                            [`players/${newHostId}/isHost`]: true
                        });
                        console.log(`Host transferred to ${newHostPlayer.name}`);
                    }
                } else if (isHost && playerCount === 1) {
                    // Last player leaving, delete the game
                    await database.ref(`games/${gameCode}`).remove();
                } else if (playerCount === 1) {
                    // Last non-host player leaving, delete the game
                    await database.ref(`games/${gameCode}`).remove();
                }

                // Clear localStorage and return to home
                localStorage.removeItem('dictionaryGame_code');
                localStorage.removeItem('dictionaryGame_playerId');
                localStorage.removeItem('dictionaryGame_playerName');

                alert('You have left the game.');
                setView('home');
            };

            if (view === 'home') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <div className="flex justify-center mb-4">
                                    <DictionaryLogo size={80} />
                                </div>
                                <h1 className="text-3xl font-bold text-purple-900 mb-2">Dictionary Game</h1>
                                <p className="text-gray-600">Multiplayer word bluffing game</p>
                            </div>

                            <div className="space-y-4">
                                <button onClick={() => setView('host')} className="w-full px-6 py-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-semibold text-lg">
                                    Host New Game
                                </button>

                                <button onClick={() => setView('join')} className="w-full px-6 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-semibold text-lg">
                                    Join Game
                                </button>
                            </div>

                            {gameHistory.length > 0 && (
                                <div className="mt-8">
                                    <h2 className="text-lg font-semibold text-gray-700 mb-3">Recent Games</h2>
                                    <div className="space-y-2 max-h-64 overflow-y-auto">
                                        {gameHistory.map((game, idx) => (
                                            <div key={idx} className="bg-gray-50 p-3 rounded text-sm">
                                                <div className="flex justify-between items-start mb-1">
                                                    <span className="font-semibold text-purple-900">üèÜ {game.winner?.name}</span>
                                                    <span className="text-xs text-gray-500">{new Date(game.endedAt).toLocaleDateString()}</span>
                                                </div>
                                                <div className="text-xs text-gray-600">
                                                    {game.players?.slice(0, 3).map(p => `${p.name} (${p.score})`).join(', ')}
                                                    {game.players?.length > 3 && '...'}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (view === 'host') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full">
                            <div className="flex items-center gap-3 mb-6">
                                <DictionaryLogo size={48} />
                                <h2 className="text-2xl font-bold text-purple-900">Host New Game</h2>
                            </div>

                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium mb-2">Your Name</label>
                                    <input type="text" value={playerName} onChange={(e) => setPlayerName(e.target.value)} placeholder="Enter your name" className="w-full px-4 py-2 border rounded-lg" />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium mb-2">Choose Your Avatar</label>
                                    <div className="grid grid-cols-5 gap-2">
                                        {avatarOptions.map((avatar) => (
                                            <button
                                                key={avatar.id}
                                                onClick={() => setSelectedAvatar(avatar.id)}
                                                className={`p-3 text-3xl rounded-lg border-2 transition ${
                                                    selectedAvatar === avatar.id
                                                        ? 'border-purple-600 bg-purple-50'
                                                        : 'border-gray-200 hover:border-purple-300'
                                                }`}
                                                title={avatar.label}
                                            >
                                                {avatar.emoji}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <button onClick={createGame} disabled={!playerName.trim()} className="w-full px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:bg-gray-400">
                                    Create Game
                                </button>

                                <button onClick={() => setView('home')} className="w-full px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">
                                    Back
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (view === 'join') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full">
                            <div className="flex items-center gap-3 mb-6">
                                <DictionaryLogo size={48} />
                                <h2 className="text-2xl font-bold text-purple-900">Join Game</h2>
                            </div>

                            {availableGames.length > 0 && (
                                <div className="mb-6">
                                    <h3 className="text-sm font-semibold text-gray-700 mb-2">Active Games:</h3>
                                    <div className="space-y-2 max-h-48 overflow-y-auto">
                                        {availableGames.map((game) => (
                                            <button
                                                key={game.code}
                                                onClick={() => quickJoinGame(game.code)}
                                                className="w-full text-left p-3 bg-blue-50 hover:bg-blue-100 rounded-lg border border-blue-200"
                                            >
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <span className="font-mono font-bold text-blue-900">{game.code}</span>
                                                        <span className="text-sm text-gray-600 ml-2">‚Ä¢ Host: {game.hostName}</span>
                                                    </div>
                                                    <span className="text-sm text-gray-500">{game.playerCount} players</span>
                                                </div>
                                            </button>
                                        ))}
                                    </div>
                                    <p className="text-xs text-gray-500 mt-2">Click a game to auto-fill the code</p>
                                </div>
                            )}

                            <div className="space-y-4">{availableGames.length > 0 && <p className="text-sm text-gray-600 text-center">Or enter code manually:</p>}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Game Code</label>
                                    <input type="text" value={inputGameCode} onChange={(e) => setInputGameCode(e.target.value.toUpperCase())} placeholder="Enter 6-digit code" maxLength="6" className="w-full px-4 py-2 border rounded-lg uppercase" />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium mb-2">Your Name</label>
                                    <input type="text" value={inputPlayerName} onChange={(e) => setInputPlayerName(e.target.value)} placeholder="Enter your name" className="w-full px-4 py-2 border rounded-lg" />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium mb-2">Choose Your Avatar</label>
                                    <div className="grid grid-cols-5 gap-2">
                                        {avatarOptions.map((avatar) => (
                                            <button
                                                key={avatar.id}
                                                onClick={() => setSelectedAvatar(avatar.id)}
                                                className={`p-3 text-3xl rounded-lg border-2 transition ${
                                                    selectedAvatar === avatar.id
                                                        ? 'border-blue-600 bg-blue-50'
                                                        : 'border-gray-200 hover:border-blue-300'
                                                }`}
                                                title={avatar.label}
                                            >
                                                {avatar.emoji}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <button onClick={joinGame} disabled={!inputGameCode.trim() || !inputPlayerName.trim()} className="w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400">
                                    Join Game
                                </button>

                                <button onClick={() => setView('home')} className="w-full px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">
                                    Back
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (view === 'game' && gameData) {
                const isHost = gameData.host === playerId;
                const isDictionaryHolder = (gameData.dictionaryHolder || gameData.host) === playerId;
                const dictionaryHolderName = gameData.dictionaryHolderName || gameData.hostName;
                const players = gameData.players || {};
                const definitions = gameData.definitions || {};
                const votes = gameData.votes || {};

                // Check if current player still exists in the game
                if (!players[playerId]) {
                    return (
                        <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full text-center">
                                <h2 className="text-2xl font-bold text-red-600 mb-4">Disconnected</h2>
                                <p className="text-gray-600 mb-4">You have been removed from this game or the game has ended.</p>
                                <button
                                    onClick={() => {
                                        localStorage.removeItem('dictionaryGame_code');
                                        localStorage.removeItem('dictionaryGame_playerId');
                                        localStorage.removeItem('dictionaryGame_playerName');
                                        setView('home');
                                    }}
                                    className="px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                >
                                    Return to Home
                                </button>
                            </div>
                        </div>
                    );
                }

                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4">
                        <div className="max-w-4xl mx-auto">
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <div className="flex justify-between items-start">
                                    <div>
                                        <h1 className="text-2xl font-bold text-purple-900">Dictionary Game</h1>
                                        <p className="text-sm text-gray-600">{isHost ? 'You are the host' : `Host: ${gameData.hostName}`}</p>
                                        <p className="text-sm text-purple-600 font-medium">
                                            Dictionary Holder: {isDictionaryHolder ? 'You' : dictionaryHolderName}
                                        </p>
                                    </div>
                                    <div className="text-right">
                                        <div className="flex items-center gap-2 bg-purple-100 px-4 py-2 rounded-lg mb-2">
                                            <span className="font-mono font-bold text-purple-900 text-xl">{gameCode}</span>
                                            <button onClick={copyGameCode} className="text-purple-600 hover:text-purple-800 text-sm">Copy</button>
                                        </div>
                                        <div className="flex gap-2">
                                            {isDictionaryHolder && gameData.state === 'setup' && (
                                                <button onClick={restartRound} className="px-3 py-1 bg-orange-500 text-white rounded text-sm hover:bg-orange-600">
                                                    Restart Round
                                                </button>
                                            )}
                                            <button onClick={leaveGame} className="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                                                Leave Game
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <h2 className="text-lg font-semibold mb-3">Players ({Object.keys(players).length})</h2>
                                {isHost && gameData.state === 'setup' && (
                                    <div className="mb-3 p-3 bg-blue-50 rounded">
                                        <label className="block text-sm font-medium mb-2">Change Dictionary Holder:</label>
                                        <select
                                            value={gameData.dictionaryHolder || gameData.host}
                                            onChange={(e) => changeDictionaryHolder(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            {Object.entries(players).map(([id, player]) => (
                                                <option key={id} value={id}>{player.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                )}
                                <div className="grid grid-cols-2 gap-2">
                                    {Object.entries(players).map(([id, player]) => {
                                        const avatar = avatarOptions.find(a => a.id === player.avatar);
                                        return (
                                            <div key={id} className="flex justify-between items-center bg-purple-50 p-3 rounded">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-2xl">{avatar?.emoji || 'üë§'}</span>
                                                    <span className="font-medium">{player.name}</span>
                                                </div>
                                                <span className="text-purple-700">{player.score}</span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {isHost && gameData.state === 'setup' && (
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                    <h2 className="text-xl font-semibold mb-4">Setup Round</h2>

                                    <div className="space-y-4">
                                        <div>
                                            <label className="block text-sm font-medium mb-2">Difficulty</label>
                                            <select value={difficulty} onChange={(e) => setDifficulty(e.target.value)} className="w-full px-3 py-2 border rounded">
                                                <option value="kids">Kids (8-12)</option>
                                                <option value="teen">Teens</option>
                                                <option value="adult">Adults</option>
                                            </select>
                                        </div>

                                        <div>
                                            <label className="block text-sm font-medium mb-2">Word</label>
                                            <div className="flex gap-2 mb-2">
                                                <input type="text" value={currentWord} onChange={(e) => setCurrentWord(e.target.value)} placeholder="Enter word" className="flex-1 px-3 py-2 border rounded" />
                                                <button onClick={getRandomWord} disabled={loadingWord} className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">
                                                    {loadingWord ? 'Loading...' : 'Random'}
                                                </button>
                                            </div>
                                            {currentWord && usedWords.includes(currentWord.toLowerCase().trim()) && (
                                                <p className="text-sm text-orange-600 mb-2">‚ö†Ô∏è This word has been used before</p>
                                            )}
                                            {currentWord && skippedWords.includes(currentWord.toLowerCase().trim()) && (
                                                <p className="text-sm text-red-600 mb-2">‚ö†Ô∏è This word was previously skipped</p>
                                            )}
                                        </div>

                                        <div>
                                            <label className="block text-sm font-medium mb-2">Real Definition</label>
                                            <div className="space-y-2">
                                                <textarea value={realDefinition} onChange={(e) => setRealDefinition(e.target.value)} placeholder="Enter the real definition" className="w-full px-3 py-2 border rounded h-24" />
                                                <button onClick={getDefinition} disabled={loadingDefinition || !currentWord.trim()} className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400">
                                                    {loadingDefinition ? 'Loading...' : 'Get Definition'}
                                                </button>
                                                <p className="text-xs text-gray-500">Click "Get Definition" to auto-fill from online dictionary</p>
                                            </div>
                                        </div>

                                        <button onClick={startRound} className="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700">
                                            Start Collecting Definitions
                                        </button>

                                        <button onClick={skipWord} disabled={!currentWord.trim()} className="w-full px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 disabled:bg-gray-400">
                                            Skip Word (Too Easy/Already Known)
                                        </button>

                                        {(usedWords.length > 0 || skippedWords.length > 0) && (
                                            <div className="mt-4 p-3 bg-gray-50 rounded">
                                                <div className="flex justify-between items-center mb-2">
                                                    <span className="text-sm font-medium text-gray-700">
                                                        Word History: {usedWords.length} used, {skippedWords.length} skipped
                                                    </span>
                                                    <button onClick={clearWordHistory} className="text-xs text-red-600 hover:text-red-700 underline">
                                                        Clear History
                                                    </button>
                                                </div>
                                                {usedWords.length > 0 && (
                                                    <div className="mb-2">
                                                        <p className="text-xs font-semibold text-gray-600">Used:</p>
                                                        <p className="text-xs text-gray-600">{usedWords.slice(-10).reverse().join(', ')}{usedWords.length > 10 && '...'}</p>
                                                    </div>
                                                )}
                                                {skippedWords.length > 0 && (
                                                    <div>
                                                        <p className="text-xs font-semibold text-gray-600">Skipped:</p>
                                                        <p className="text-xs text-gray-600">{skippedWords.slice(-10).reverse().join(', ')}{skippedWords.length > 10 && '...'}</p>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {!isDictionaryHolder && gameData.state === 'setup' && (
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-4 text-center">
                                    <p className="text-gray-600">Waiting for host to start the round...</p>
                                </div>
                            )}

                            {gameData.state === 'collecting' && (
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                    <h2 className="text-xl font-semibold mb-2">{isDictionaryHolder ? 'Definitions Coming In' : 'Submit Your Definition'}</h2>
                                    <p className="text-gray-600 mb-4">Word: <span className="font-bold text-lg">{gameData.currentWord}</span></p>

                                    {!isDictionaryHolder && !definitions[playerId] && (
                                        <div className="space-y-3">
                                            <textarea value={myDefinition} onChange={(e) => setMyDefinition(e.target.value)} placeholder="Write a fake definition..." className="w-full px-3 py-2 border rounded h-24" />
                                            <button onClick={submitDefinition} className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                                                Submit Definition
                                            </button>
                                        </div>
                                    )}

                                    {!isDictionaryHolder && definitions[playerId] && (
                                        <div className="bg-green-50 p-4 rounded">
                                            <p className="text-green-800 font-semibold">‚úì Your definition submitted!</p>
                                        </div>
                                    )}

                                    {isDictionaryHolder && (
                                        <div className="space-y-3">
                                            <p className="text-sm text-gray-600">
                                                Definitions received: {Object.keys(definitions).length} / {Object.keys(players).length - 1}
                                            </p>
                                            {Object.keys(definitions).map((defId, idx) => (
                                                <div key={defId} className="bg-gray-50 p-3 rounded">
                                                    <p className="text-sm font-medium text-gray-600">Definition {idx + 1}</p>
                                                    <p className="text-gray-800">{definitions[defId].text}</p>
                                                </div>
                                            ))}
                                            {Object.keys(definitions).length > 0 && (
                                                <button onClick={startVoting} className="w-full px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                                                    Start Voting
                                                </button>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}

                            {gameData.state === 'voting' && (
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                    <h2 className="text-xl font-semibold mb-2">Vote for the Real Definition</h2>
                                    <p className="text-gray-600 mb-4">Word: <span className="font-bold text-lg">{gameData.currentWord}</span></p>

                                    {!isDictionaryHolder && (
                                        <div className="space-y-3">
                                            {[...Object.entries(definitions).filter(([id]) => id !== playerId), ['real', { text: gameData.realDefinition }]]
                                                .sort(() => Math.random() - 0.5)
                                                .map(([id, def]) => {
                                                    const voted = myVote === id;
                                                    return (
                                                        <button key={id} onClick={() => castVote(id)} className={`w-full text-left p-4 rounded-lg border-2 ${voted ? 'border-green-500 bg-green-50' : 'border-gray-200 hover:border-purple-300'}`}>
                                                            {def.text}
                                                            {voted && <span className="ml-2 text-green-600 font-semibold">‚úì</span>}
                                                        </button>
                                                    );
                                                })}
                                        </div>
                                    )}

                                    {isDictionaryHolder && (
                                        <div className="space-y-3">
                                            <p className="text-sm text-gray-600">
                                                Votes cast: {Object.keys(votes).length} / {Object.keys(players).length - 1}
                                            </p>
                                            {Object.keys(votes).length >= Object.keys(players).length - 1 && (
                                                <button onClick={showResults} className="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700">
                                                    Show Results
                                                </button>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}

                            {gameData.state === 'results' && (
                                <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                    <h2 className="text-xl font-semibold mb-4">Round Results</h2>

                                    <div className="mb-6 p-4 bg-green-50 rounded-lg">
                                        <h3 className="font-semibold text-green-900 mb-2">Real Definition:</h3>
                                        <p className="text-gray-800">{gameData.realDefinition}</p>
                                        <p className="text-sm text-green-700 mt-2">Votes: {gameData.voteCounts?.real || 0}</p>
                                    </div>

                                    <div className="space-y-3 mb-6">
                                        <h3 className="font-semibold">Player Definitions:</h3>
                                        {Object.entries(definitions).map(([defId, def]) => {
                                            const playerInfo = players[defId];
                                            const voteCount = gameData.voteCounts?.[defId] || 0;
                                            return (
                                                <div key={defId} className="p-4 bg-purple-50 rounded-lg">
                                                    <p className="font-semibold text-purple-900">{playerInfo?.name}:</p>
                                                    <p className="text-gray-800 mt-1">{def.text}</p>
                                                    <p className="text-sm text-purple-700 mt-2">Votes: {voteCount}</p>
                                                </div>
                                            );
                                        })}
                                    </div>

                                    {isHost && (
                                        <button onClick={newRound} className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                                            New Round
                                        </button>
                                    )}

                                    {!isHost && (
                                        <p className="text-center text-gray-600">Waiting for host to start next round...</p>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            return <div className="min-h-screen flex items-center justify-center">
                <p className="text-gray-600">Loading...</p>
            </div>;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MultiplayerDictionaryGame />);
    </script>
</body>
</html>