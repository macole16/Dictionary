<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictionary Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        // Suppress Tailwind CDN warning
        const originalWarn = console.warn;
        console.warn = function(...args) {
            if (args[0]?.includes?.('cdn.tailwindcss.com')) return;
            originalWarn.apply(console, args);
        };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        // Lucide icons as inline SVGs
        const BookOpen = () => (
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        );

        const Users = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M22 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
        );

        const Trophy = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                <path d="M4 22h16"></path>
                <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
            </svg>
        );

        const Play = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const RotateCcw = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );

        function DictionaryGame() {
            const [gameState, setGameState] = useState('setup');
            const [players, setPlayers] = useState([]);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [dictionaryHolder, setDictionaryHolder] = useState('');
            const [currentWord, setCurrentWord] = useState('');
            const [realDefinition, setRealDefinition] = useState('');
            const [definitions, setDefinitions] = useState([]);
            const [newDefinition, setNewDefinition] = useState('');
            const [currentPlayer, setCurrentPlayer] = useState('');
            const [votes, setVotes] = useState({});
            const [roundHistory, setRoundHistory] = useState([]);
            const [loadingWord, setLoadingWord] = useState(false);
            const [loadingDefinition, setLoadingDefinition] = useState(false);
            const [usedWords, setUsedWords] = useState([]);
            const [storageLoaded, setStorageLoaded] = useState(false);

            // Load used words from localStorage
            useEffect(() => {
                const loadUsedWords = () => {
                    try {
                        const stored = localStorage.getItem('balderdash-used-words');
                        if (stored) {
                            setUsedWords(JSON.parse(stored));
                        }
                    } catch (error) {
                        console.log('No previous words found or error loading:', error);
                    }
                    setStorageLoaded(true);
                };
                loadUsedWords();
            }, []);

            // Save used words to localStorage
            const saveUsedWords = (words) => {
                try {
                    localStorage.setItem('balderdash-used-words', JSON.stringify(words));
                } catch (error) {
                    console.error('Error saving used words:', error);
                }
            };

            // Get random word
            const getRandomWord = async () => {
                setLoadingWord(true);
                try {
                    let word = null;
                    
                    try {
                        const response = await fetch('https://random-word-api.vercel.app/api?words=1&length=7');
                        const data = await response.json();
                        if (data && data[0]) {
                            word = data[0];
                        }
                    } catch (e) {
                        console.log('First API failed, trying backup...');
                    }
                    
                    if (!word) {
                        const obscureWords = [
                            'absquatulate', 'bumfuzzle', 'callipygian', 'defenestrate', 'erinaceous',
                            'floccinaucinihilipilification', 'gobemouche', 'higgler', 'impignorate',
                            'jentacular', 'kakistocracy', 'lollygag', 'malarkey', 'nudiustertian',
                            'octothorpe', 'pauciloquent', 'quomodocunquize', 'rhadamanthine',
                            'smellfungus', 'taradiddle', 'ulotrichous', 'vomitory', 'wabbit',
                            'xertz', 'yarborough', 'zenzizenzizenzic', 'borborygmus', 'collywobbles',
                            'donnybrook', 'fartlek', 'gardyloo', 'hobbledehoy', 'kerfuffle',
                            'lollop', 'meldrop', 'nidificate', 'obnubilate', 'panjandrum',
                            'quockerwodger', 'ratoon', 'skirr', 'tittynope', 'ugsome',
                            'vagarious', 'widdershins', 'xyst', 'zoanthropy', 'abligurition'
                        ];
                        word = obscureWords[Math.floor(Math.random() * obscureWords.length)];
                    }
                    
                    setCurrentWord(word);
                } catch (error) {
                    alert('Could not fetch random word. Please try again or enter one manually.');
                }
                setLoadingWord(false);
            };

            // Get definition for current word
            const getDefinition = async () => {
                if (!currentWord.trim()) {
                    alert('Please enter a word first');
                    return;
                }
                
                setLoadingDefinition(true);
                try {
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${currentWord.toLowerCase()}`);
                    
                    if (!response.ok) {
                        throw new Error('Word not found');
                    }
                    
                    const data = await response.json();
                    
                    if (data && data[0] && data[0].meanings && data[0].meanings[0]) {
                        const definition = data[0].meanings[0].definitions[0].definition;
                        setRealDefinition(definition.charAt(0).toUpperCase() + definition.slice(1));
                    } else {
                        alert('Could not find definition for "' + currentWord + '". Try another word or enter definition manually.');
                    }
                } catch (error) {
                    console.error('Definition fetch error:', error);
                    alert('Could not fetch definition for "' + currentWord + '". The word might not be in the dictionary, or there may be a connection issue. Please enter the definition manually or try a different word.');
                }
                setLoadingDefinition(false);
            };

            const addPlayer = () => {
                if (newPlayerName.trim() && !players.find(p => p.name === newPlayerName.trim())) {
                    setPlayers([...players, { name: newPlayerName.trim(), score: 0 }]);
                    setNewPlayerName('');
                }
            };

            const startRound = () => {
                if (!dictionaryHolder || !currentWord.trim() || !realDefinition.trim()) {
                    alert('Please fill in dictionary holder, word, and real definition');
                    return;
                }
                
                const wordLower = currentWord.toLowerCase().trim();
                if (usedWords.includes(wordLower)) {
                    if (!confirm(`"${currentWord}" has been used before. Use it anyway?`)) {
                        return;
                    }
                } else {
                    const updatedWords = [...usedWords, wordLower];
                    setUsedWords(updatedWords);
                    saveUsedWords(updatedWords);
                }
                
                setGameState('collecting');
                setDefinitions([]);
                setVotes({});
            };

            const submitDefinition = () => {
                if (!currentPlayer || !newDefinition.trim()) {
                    alert('Please select your name and enter a definition');
                    return;
                }
                if (currentPlayer === dictionaryHolder) {
                    alert('Dictionary holder cannot submit a fake definition!');
                    return;
                }
                if (definitions.find(d => d.player === currentPlayer)) {
                    alert('You already submitted a definition!');
                    return;
                }
                setDefinitions([...definitions, { player: currentPlayer, text: newDefinition.trim() }]);
                setNewDefinition('');
                setCurrentPlayer('');
            };

            const startVoting = () => {
                if (definitions.length === 0) {
                    alert('Need at least one fake definition to start voting');
                    return;
                }
                setGameState('voting');
            };

            const castVote = (defIndex, voterName) => {
                if (voterName === dictionaryHolder) {
                    alert('Dictionary holder cannot vote!');
                    return;
                }
                const def = defIndex === 'real' ? { player: 'REAL' } : definitions[defIndex];
                if (def.player === voterName) {
                    alert('You cannot vote for your own definition!');
                    return;
                }
                setVotes({...votes, [voterName]: defIndex});
            };

            const showResults = () => {
                const voteCounts = {};
                Object.values(votes).forEach(defIndex => {
                    voteCounts[defIndex] = (voteCounts[defIndex] || 0) + 1;
                });

                const updatedPlayers = [...players];
                
                definitions.forEach((def, idx) => {
                    const playerIndex = updatedPlayers.findIndex(p => p.name === def.player);
                    if (playerIndex !== -1 && voteCounts[idx]) {
                        updatedPlayers[playerIndex].score += voteCounts[idx];
                    }
                });

                if (voteCounts['real']) {
                    const holderIndex = updatedPlayers.findIndex(p => p.name === dictionaryHolder);
                    if (holderIndex !== -1) {
                        updatedPlayers[holderIndex].score += voteCounts['real'];
                    }
                }

                setPlayers(updatedPlayers);
                setRoundHistory([...roundHistory, {
                    word: currentWord,
                    real: realDefinition,
                    definitions,
                    votes: voteCounts
                }]);
                setGameState('results');
            };

            const newRound = () => {
                setGameState('setup');
                setCurrentWord('');
                setRealDefinition('');
                setDefinitions([]);
                setVotes({});
            };

            const restartToSetup = () => {
                newRound();
            };

            const resetGame = () => {
                if (confirm('Reset entire game? All scores will be lost.')) {
                    setPlayers(players.map(p => ({...p, score: 0})));
                    setRoundHistory([]);
                    newRound();
                }
            };

            const clearWordHistory = () => {
                if (confirm('Clear all previously used words? This cannot be undone.')) {
                    setUsedWords([]);
                    try {
                        localStorage.removeItem('balderdash-used-words');
                        alert('Word history cleared!');
                    } catch (error) {
                        console.error('Error clearing word history:', error);
                    }
                }
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4">
                    <div className="max-w-4xl mx-auto">
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                            <div className="flex justify-between items-start mb-2">
                                <div>
                                    <h1 className="text-3xl font-bold text-purple-900 flex items-center gap-2">
                                        <BookOpen />
                                        Dictionary Game
                                    </h1>
                                    <p className="text-gray-600 text-sm">Dictionary bluffing game scorer</p>
                                </div>
                                {gameState !== 'setup' && (
                                    <button
                                        onClick={restartToSetup}
                                        className="px-3 py-1.5 bg-orange-600 text-white rounded text-sm hover:bg-orange-700 flex items-center gap-1"
                                    >
                                        <RotateCcw />
                                        Restart Round
                                    </button>
                                )}
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                            <h2 className="text-xl font-semibold mb-3 flex items-center gap-2">
                                <Users />
                                Players
                            </h2>
                            
                            <div className="flex gap-2 mb-4">
                                <input
                                    type="text"
                                    value={newPlayerName}
                                    onChange={(e) => setNewPlayerName(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && addPlayer()}
                                    placeholder="Player name"
                                    className="flex-1 px-3 py-2 border rounded"
                                />
                                <button onClick={addPlayer} className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">
                                    Add
                                </button>
                            </div>

                            <div className="grid grid-cols-2 gap-2">
                                {players.map((player, idx) => (
                                    <div key={idx} className="flex justify-between items-center bg-purple-50 p-3 rounded">
                                        <span className="font-medium">{player.name}</span>
                                        <span className="flex items-center gap-1 text-purple-700">
                                            <Trophy />
                                            {player.score}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {gameState === 'setup' && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <h2 className="text-xl font-semibold mb-4">Setup Round</h2>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Dictionary Holder</label>
                                        <select 
                                            value={dictionaryHolder}
                                            onChange={(e) => setDictionaryHolder(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="">Select player...</option>
                                            {players.map((p, idx) => (
                                                <option key={idx} value={p.name}>{p.name}</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-1">Word</label>
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                value={currentWord}
                                                onChange={(e) => setCurrentWord(e.target.value)}
                                                placeholder="Enter the word from dictionary"
                                                className="flex-1 px-3 py-2 border rounded"
                                            />
                                            <button
                                                onClick={getRandomWord}
                                                disabled={loadingWord}
                                                className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 disabled:bg-gray-400 whitespace-nowrap"
                                            >
                                                {loadingWord ? 'Loading...' : 'Random Word'}
                                            </button>
                                        </div>
                                        {currentWord && usedWords.includes(currentWord.toLowerCase().trim()) && (
                                            <p className="text-sm text-orange-600 mt-1">⚠️ This word has been used before</p>
                                        )}
                                        <p className="text-xs text-gray-500 mt-1">Click "Random Word" to get a suggestion, then look up the real definition</p>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-1">Real Definition</label>
                                        <div className="space-y-2">
                                            <textarea
                                                value={realDefinition}
                                                onChange={(e) => setRealDefinition(e.target.value)}
                                                placeholder="Enter the real definition"
                                                className="w-full px-3 py-2 border rounded h-24"
                                            />
                                            <button
                                                onClick={getDefinition}
                                                disabled={loadingDefinition || !currentWord.trim()}
                                                className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400"
                                            >
                                                {loadingDefinition ? 'Loading...' : 'Get Definition'}
                                            </button>
                                            <p className="text-xs text-gray-500">Click "Get Definition" to auto-fill from online dictionary</p>
                                        </div>
                                    </div>

                                    <button 
                                        onClick={startRound}
                                        className="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center justify-center gap-2"
                                    >
                                        <Play />
                                        Start Collecting Definitions
                                    </button>

                                    {usedWords.length > 0 && (
                                        <div className="mt-4 p-3 bg-gray-50 rounded">
                                            <div className="flex justify-between items-center mb-2">
                                                <span className="text-sm font-medium text-gray-700">
                                                    Words used: {usedWords.length}
                                                </span>
                                                <button
                                                    onClick={clearWordHistory}
                                                    className="text-xs text-red-600 hover:text-red-700 underline"
                                                >
                                                    Clear history
                                                </button>
                                            </div>
                                            <div className="text-xs text-gray-600 max-h-20 overflow-y-auto">
                                                {usedWords.slice(-10).reverse().join(', ')}
                                                {usedWords.length > 10 && '...'}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {gameState === 'collecting' && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <h2 className="text-xl font-semibold mb-2">Submit Your Fake Definition</h2>
                                <p className="text-sm text-gray-600 mb-4">Word: <span className="font-bold text-lg">{currentWord}</span></p>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Your Name</label>
                                        <select 
                                            value={currentPlayer}
                                            onChange={(e) => setCurrentPlayer(e.target.value)}
                                            className="w-full px-3 py-2 border rounded"
                                        >
                                            <option value="">Select your name...</option>
                                            {players.filter(p => p.name !== dictionaryHolder).map((p, idx) => (
                                                <option key={idx} value={p.name}>{p.name}</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-1">Your Definition</label>
                                        <textarea
                                            value={newDefinition}
                                            onChange={(e) => setNewDefinition(e.target.value)}
                                            placeholder="Make it sound believable!"
                                            className="w-full px-3 py-2 border rounded h-24"
                                        />
                                    </div>

                                    <button 
                                        onClick={submitDefinition}
                                        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        Submit Definition
                                    </button>
                                </div>

                                <div className="mt-6">
                                    <h3 className="font-semibold mb-2">Submitted ({definitions.length}):</h3>
                                    <div className="space-y-2">
                                        {definitions.map((def, idx) => (
                                            <div key={idx} className="bg-gray-50 p-2 rounded text-sm">
                                                ✓ {def.player}
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <button 
                                    onClick={startVoting}
                                    className="w-full mt-4 px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                >
                                    Start Voting
                                </button>
                            </div>
                        )}

                        {gameState === 'voting' && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <h2 className="text-xl font-semibold mb-2">Vote for the Real Definition</h2>
                                <p className="text-sm text-gray-600 mb-4">Word: <span className="font-bold text-lg">{currentWord}</span></p>
                                
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-1">Your Name</label>
                                    <select 
                                        value={currentPlayer}
                                        onChange={(e) => setCurrentPlayer(e.target.value)}
                                        className="w-full px-3 py-2 border rounded"
                                    >
                                        <option value="">Select your name...</option>
                                        {players.filter(p => p.name !== dictionaryHolder).map((p, idx) => (
                                            <option key={idx} value={p.name}>{p.name}</option>
                                        ))}
                                    </select>
                                </div>

                                <div className="space-y-3">
                                    {[...definitions, { player: 'REAL', text: realDefinition }]
                                        .sort(() => Math.random() - 0.5)
                                        .map((def, idx) => {
                                            const defIndex = def.player === 'REAL' ? 'real' : definitions.findIndex(d => d.player === def.player);
                                            const voted = votes[currentPlayer] === defIndex;
                                            
                                            return (
                                                <button
                                                    key={idx}
                                                    onClick={() => currentPlayer && castVote(defIndex, currentPlayer)}
                                                    disabled={!currentPlayer}
                                                    className={`w-full text-left p-4 rounded-lg border-2 transition ${
                                                        voted 
                                                            ? 'border-green-500 bg-green-50' 
                                                            : 'border-gray-200 hover:border-purple-300'
                                                    } ${!currentPlayer ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
                                                >
                                                    {def.text}
                                                    {voted && <span className="ml-2 text-green-600 font-semibold">✓ Your vote</span>}
                                                </button>
                                            );
                                        })}
                                </div>

                                <div className="mt-4 text-sm text-gray-600">
                                    Votes cast: {Object.keys(votes).length} / {players.length - 1}
                                </div>

                                <button 
                                    onClick={showResults}
                                    className="w-full mt-4 px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700"
                                >
                                    Show Results
                                </button>
                            </div>
                        )}

                        {gameState === 'results' && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-4">
                                <h2 className="text-xl font-semibold mb-4">Round Results</h2>
                                
                                <div className="mb-6 p-4 bg-green-50 rounded-lg">
                                    <h3 className="font-semibold text-green-900 mb-2">Real Definition:</h3>
                                    <p className="text-gray-800">{realDefinition}</p>
                                    <p className="text-sm text-green-700 mt-2">
                                        Votes: {Object.values(votes).filter(v => v === 'real').length}
                                    </p>
                                </div>

                                <div className="space-y-3 mb-6">
                                    {definitions.map((def, idx) => {
                                        const voteCount = Object.values(votes).filter(v => v === idx).length;
                                        return (
                                            <div key={idx} className="p-4 bg-purple-50 rounded-lg">
                                                <p className="font-semibold text-purple-900">{def.player}'s definition:</p>
                                                <p className="text-gray-800 mt-1">{def.text}</p>
                                                <p className="text-sm text-purple-700 mt-2">Votes: {voteCount}</p>
                                            </div>
                                        );
                                    })}
                                </div>

                                <div className="flex gap-2">
                                    <button 
                                        onClick={newRound}
                                        className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex items-center justify-center gap-2"
                                    >
                                        <RotateCcw />
                                        New Round
                                    </button>
                                    <button 
                                        onClick={resetGame}
                                        className="px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700"
                                    >
                                        Reset Game
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DictionaryGame />);
    </script>
</body>
</html>
